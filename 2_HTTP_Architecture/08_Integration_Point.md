# 8장 통합점: 게이트웨이, 터널, 릴레이 `Serin Yoon`
여러 종류의 리소스에 접근하는데 HTTP가 어떻게 쓰이는지 알아보는 장. 게이트웨이, 애플리케이션 인터페이스, 터널, 릴레이에 대해 다루는 장
<br><br>

### 8.1 게이트웨이
1. 게이트웨이는 _____와 _____을 연결하는 역할을 한다.
2. 게이트웨이는 클라이언트 측 프로토콜과 서버 측 프로토콜을 ___으로 구분해 기술한다.
<details>
<summary> <b> 📄 답지 </b>  </summary>
<div markdown="1">

1. 게이트웨이는 **리소스**와 **애플리케이션**을 연결하는 역할을 한다.
> 애플리케이션은 게이트웨이에 요청을 처리해달라고 할 수 있고, 게이트웨이는 그에 응답할 수 있다. **p.228**
2. 게이트웨이는 클라이언트 측 프로토콜과 서버 측 프로토콜을 **빗금**으로 구분해 기술한다.
> ex. 게이트웨이가 HTTP 클라이언트와 NNTP 서버 사이에 있으면 HTTP/NNTP 게이트웨이가 됨. **p.230**
</div>
</details>
<br>

### 8.2 프로토콜 게이트웨이
1. 서버 측 웹 게이트웨이는 클라이언트로부터 HTTP 요청이 원 서버 영역으로 들어오는 시점에 클라이언트 측의 HTTP 요청을 외래 프로토콜로 전환한다. (O/X)
2. 서버 측 보안 게이트웨이는 자동으로 사용자의 모든 세션을 암호화한다. (O/X)
<details>
<summary> <b> 📄 답지 </b>  </summary>
<div markdown="1">

1. **O**
> 그림 8-5를 보면, HTTP/FTP 게이트웨이가 HTTP 요청을 FTP 요청으로 변환하고 있다.  **p.232**
2. **O**
> 그림 8-6을 보면, HTTP/HTTPS 인바운드 보안 게이트웨이는 SSL을 통해 요청을 암호화한다. **p.232**
</div>
</details>
<br>


### 8.3 리소스 게이트웨이
1. 그림 8-8을 참고하여 애플리케이션 서버의 작동 순서를 맞춰보자. <br>
	a) 요청의 URI를 따라 웹 카메라 API를 통해 카메라 애플리케이션에 요청을 전송한다. <br>
	b) 클라이언트 A가 요청을 보낸다. <br>
	c) 응답 메시지가 카메라 이미지를 포함하여 클라이언트로 전송된다. <br>
	d) 클라이언트의 브라우저에 카메라 이미지가 보인다.
<details>
<summary> <b> 📄 답지 </b>  </summary>
<div markdown="1">

1. **b - a - c - d**
> 클라이언트 A의 요청을 받으면, 그 요청의 URI를 따라서 API를 통해 카메라 어플리케이션에 요청이 전송된다. HTTP 응답 메시지는 카메라 이미지를 감싸 클라이언트로 전송하고, 클라이언트의 브라우저에 이미지가 보이게 된다.  **p.234**
</div>
</details>
<br>

### 8.4 애플리케이션 인터페이스와 웹 서비스
1. 웹 서비스는 SOAP(Simple Object Access Protocol)을 통해 ____을 사용하여 정보를 교환한다. SOAP은 HTTP 메시지에 ____ 데이터를 담는 방식에 관한 표준이다.
<details>
<summary> <b> 📄 답지 </b>  </summary>
<div markdown="1">

3. **XML(eXtensible Markup Language)**
> SOAP(Simple Object Access Protocol)은 일반적으로 널리 알려진 HTTP, HTTPS, SMTP 등을 통해 XML 기반의 메시지를 컴퓨터 네트워크 상에서 교환하는 프로토콜이다. **p.237, 위키백과**
</div>
</details>
<br>

### 8.5 터널
1. 웹 터널은 HTTP 프로토콜을 지원하지 않는 애플리케이션에 HTTP 애플리케이션을 사용해 접근하는 방법을 제공한다. (O/X)
2.  클라이언트는 CONNECT 요청을 보낸 다음, 응답을 받기 전까지는 터널 데이터를 전송할 수 없다. (O/X)
3. SSL과 같이 암호화된 프로토콜은 낡은 방식의 프락시에서는 처리되지 않기 때문에 터널을 사용한다. (=SSL 터널링) (O/X)
<details>
<summary> <b> 📄 답지 </b>  </summary>
<div markdown="1">

1. **O**
> 웹 터널을 사용하면 HTTP 커넥션을 통해 HTTP가 아닌 트래픽을 전송할 수 있고, 다른 프로토콜을 HTTP 위에 올릴 수 있다. 웹 터널을 사용하는 가장 일반적인 이유는 HTTP 커넥션 안에 HTTP가 아닌 트래픽을 얹기 위해서이다. **p.238**
2. **X**
> 응답을 받기 전에 터널 데이터를 전송할 수 있다. 단, 게이트웨이가 요청에 이어 데이터를 적절하게 처리할 수 있어야 함을 전제로 한다. **p.240**
3. **O**
> 그림 8-11을 참고하면, 터널을 사용하여 SSL 트래픽을 HTTP 커넥션으로 전송하여 80 포트의 HTTP 만을 허용하는 방화벽을 통과하도록 한다. **p.241**
</div>
</details>
<br>

### 8.6 릴레이
1. 릴레이는 Connection 헤더를 이해하지 못한다. (O/X)
2. 릴레이를 사용할 때 발생할 수 있는 문제를 정리한 것이다. 옳은 순서로 바꿔보자. <br>
	a) 릴레이가 이 Connection 헤더를 서버로 넘긴다. <br>
	b) 릴레이가 이 Connection 헤더를 클라이언트로 넘긴다. <br>
	c) 클라이언트가 Connection: Keep-Alive 헤더를 릴레이로 보낸다. <br>
	d) 서버가 Connection: Keep-Alive 헤더로 응답한다. <br>
	e) 서버는 릴레이가 Keep-Alive를 하기 바란다고 판단한다. <br>
	f) 클라이언트는 릴레이가 Keep-Alive로 통신하는 것에 동의했다고 판단한다.
<details>
<summary> <b> 📄 답지 </b>  </summary>
<div markdown="1">

1. **O**
> 릴레이는 단순히 바이트를 전달하는 기능을 한다. 그렇기 때문에 Connection 헤더를 이해하지 못한다. **p.244**
2. **c - a - e - d - b - f**
> 클라이언트가 Connection: Keep-Alive 헤더를 릴레이에게 보낸다 → 릴레이는 이 Connection 헤더를 서버로 넘긴다 → 서버는 릴레이가 Keep-Alive를 하기 바란다고 판단한다 → 서버가 Connection: Keep-Alive 헤더로 응답한다 → 릴레이는 이 Connection 헤더를 클라이언트로 넘긴다 → 클라이언트는 릴레이가 Keep-Alive로 통신하는 것에 동의했다고 판단한다 **p.245**
</div>
</details>
